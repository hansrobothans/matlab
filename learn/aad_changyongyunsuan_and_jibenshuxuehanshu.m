clc  ,clear ,close all 
%常用运算和基本数学函数

%常用矩阵运算函数
%det %求矩阵的行列式
%inv %求矩阵的逆
%eig %求矩阵的特征值和特征向量
%rank %求矩阵的秩
%trace %求矩阵的迹
%norm %求矩阵的范数
%poly %求矩阵特征方程的根
%fliplr %矩阵左右翻转
%flipud %矩阵上下翻转
%resharp %矩阵阶数重组
%rot90 %矩阵逆时针旋转90°
%diag %提取或者建立对角矩阵
%tril %取矩阵的左下三角部分
%triu %取矩阵的右上三角部分

%1、方程的解
%已知线性方程组
%  6*x1+3*x2+4*x3= 3
% -2*x1+5*x2+7*x3=-4
%  8*x1-  x2-3*x3=-7

%方程的解采用矩阵的逆运算或者采用左除运算
%（1）采用求逆运算：x=inv(A)b;
%（2）采用左除运算：x=A/b.
%说明
%（1）matlab遵循IEEE算法，即使A奇异，该运算也照样运行。但在结束后，一方面会提出警告‘warning: Matrix is
%singular to working precision’,另一方面所得的逆矩阵的元素都是‘Inf’（无穷大）
%（2）当A为“病态”时，也给出警告信息
%（3）在matlab中求逆inv()函数较少使用，使用matlab时应尽量用除运算，少用逆运算

% A = [6,3,4;
%     -2,5,7;
%     8,-1,-3];
% B = [3,;-4;-7];
% x1 = inv(A) * B
% x2 = A\B

%2、矩阵的秩
%调用格式：R=rank(A)
%其中A为输入矩阵，B为输出的矩阵A的秩
% A = [6,3,4;
%     -2,5,7;
%     8,-1,-3];
% r = rank(A)


%3、矩阵的特征值与特征向量
%调用格式：[v,lambda]=eig(A).
%其中A为输入矩阵；v为输出的矩阵A的特征向量；lambda为输出的矩阵A的特征值
% A = [6,3,4;
%     -2,5,7;
%     8,-1,-3];
% [v,lambda] = eig(A)

%4、矩阵的乘幂与开方
% A = [6,3,4;
%     -2,5,7;
%     8,-1,-3];
% A1 = A^2      %乘幂
% A2 = sqrt(A)  %开方

%5、矩阵的指数与对数
%（1）指数求解的调用形式：y1 = exp(A)
%（2）对数求解的调用形式：y2 = log(A)
%A为输入的矩阵或者向量值；y1为输出的矩阵A的指数值；y2为输出的矩阵A的对数值
% A = [6,3,4;
%     -2,5,7;
%     8,-1,-3];
% A3 = exp(A)  %指数
% A4 = log(A)  %对数

%6、矩阵的提取与翻转
%（1）矩阵的上三角元素提取调用格式：y1 = triu(A)
%（2）矩阵的下三角元素提取调用形式：y2 = tril(A)
%（3）矩阵的对角线元素提取调用形式：y3 = diag(A)
%其中A为输入的矩阵或者向量值；y1为输出的矩阵A的上三角元素值，其他值为0；y2为输出的矩阵A的下三角元素值，其他值为0；y3为输出的矩阵A的对角线元素值.
%（1）矩阵上下翻转调用格式：y4 = flipud(A)
%（2）矩阵左右翻转调用格式：y5 = fliplr(A)
%（3）矩阵沿列翻转调用格式：y6 = flipdim(A,1)
%（4）矩阵沿行翻转调用格式：y7 = flipdim(A,2)
%（5）矩阵逆时针旋转翻转调用格式：y8 = rot90(A)
%其中A为输入的矩阵或者向量值；y4为输出的矩阵A上下翻转后的矩阵；y5为输出的矩阵A左右翻转后的矩阵；y6为输出的矩阵A沿列翻转后的矩阵；y7为输出的矩阵A沿行翻转
%后的矩阵；y8为输出的矩阵A逆时针旋转翻转后的矩阵。

% A = [6,3,4;
%     -2,5,7;
%     8,-1,-3];
% A5 = triu(A)
% A6 = tril(A)
% A7 = diag(A)
% A8 = flipud(A)
% A9 = fliplr(A)
% A10 = flipdim(A,1)
% A11 = flipdim(A,2)
% A12 = rot90(A)


%7、‘商’及‘余’多项式
%求多项式
%[(s^2+1)*(s+3)*(s+1)]/
%(s^2+2s+1)
%的商及余多项式
%调用格式：[q,r]=decovn(p1,p2)
%p1为输入的分子多项式系数；p2为输入分母多项式系数；q为输出的该多项式的“商”的多项式；r为输出多项式的“余”的多项式。
% p1 = conv([1,0,1],conv([1,3],[1,1]));
% p2 = [1,2,1];
% [q,r] = deconv(p1,p2)
% disp(['商多项式为：',poly2str(q,'t')])
% disp(['余多项式为：',poly2str(r,'t')])



















